/*++
 Dual Purpose Tracer (DPTrace) v1.0 Alpha
 Copyright (C) 2008-2016  
	Rodrigo Rubira Branco (BSDaemon) <rodrigo@kernelhacking.com>
	Rohit Mothe <rohitwas@gmail.com>

 Heavily based on VDT-Tracer by Julio Auto and Rodrigo Branco

 This is the tracing module of DPTrace. It's a WinDbg extension
 that dumps the execution trace in a format that is suitable to be later
 consumed by the analyzer, which provides information back to the
 forward execution.

 Module Name:

    dptrace-tracer.cpp

--*/
#include <ntverp.h>
#include <time.h>
#include <string.h>
#include <assert.h>
#include <memory>
#include <map>

using namespace std;


#include "vdt-tracer.h"

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;


HRESULT
CALLBACK
DebugExtensionInitialize(
	OUT PULONG  Version,
	OUT PULONG  Flags
	)
{
	IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    Hr = S_OK;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                  (void **)&DebugControl)) == S_OK)
    {

        //
        // Get the windbg-style extension APIS
        //
        ExtensionApis.nSize = sizeof (ExtensionApis);
        Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis);

        DebugControl->Release();

    }
    DebugClient->Release();

	vdt_initmap();

    return Hr;
}

HRESULT
CALLBACK
dptrace_forward_help(PDEBUG_CLIENT Client, PCSTR args)
{
	dprintf("!dptrace_forward:\n\n");
	dprintf("[*] Two options of running-\n\n\ta) Simple Run with no arguments\n\t\t\t!dptrace_forward\n\t\t\t= > default number of objects n = 2, size s= 40, permissions are RW for first object, READONLY for all other objects");
	dprintf("\n\n\tb) If running with arguments to configure the run following rules apply - \n\t\t\t!dptrace_forward - n(required) - s(required) - p(OPTIONAL) \n\t\t\t = > number of fake objects(required), size of each object in bytes(required), page permissions(OPTIONAL)(0x02, 0x04, 0x01)(R / RW / W / NO_ACCESS, ...)\n\n\t\t\tParameters n and s are parsed in decimal(base 10). however, if passing the 3rd parameter p, specify the constants in hex eg:- '0x2', '0x40' etc.\n\n\t<Optional>For passing 'p' use the following map - \n\t\t\tPAGE_EXECUTE  0x10\n\t\t\tPAGE_EXECUTE_READ  0x20\n\t\t\tPAGE_EXECUTE_READWRITE  0x40\n\t\t\tPAGE_EXECUTE_WRITECOPY  0x80\n\t\t\tPAGE_NOACCESS  0x01\n\t\t\tPAGE_READONLY  0x02 // defualt protection if run with no arguments. \n\t\t\tPAGE_READWRITE  0x04\n\t\t\tPAGE_WRITECOPY  0x08\n\t</Optional>\n\n");

	return S_OK;
}

HRESULT
CALLBACK
dptrace_analyzer_help(PDEBUG_CLIENT Client, PCSTR args)
{
	dprintf("!dptrace_analyzer <analyzer_filepath> <trace_filepath> <close_gui> <controlled_ranges> <instr_index>:\n\n");
	dprintf("Where:\n");
	dprintf("<analyzer_filepath> - the file path to the analyzer binary (GUI)\n");
	dprintf("<trace_filepath> - the file path that contains the trace information generated by the debugger plugin\n");
	dprintf("<close_gui> - bool: {0|1} - 0 - Keep GUI Open and 1- Close GUI\n");
	dprintf("<controlled_ranges> - controlled ranges: range1start-range1end,range2start-range2end,...\n");
	dprintf("<instr_index> - index of the instruction to dump backward taint analysis\n\n");

	dprintf("Example of a command line (please note the need for the quotes): \n");
#define COMMAND_POPEN "\"\"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Debug\\DPTRACE-GUI.exe\" \"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Sample_output\\dptrace-test2.vdt\" 1 \"0x80000-0x81000,0x10000-0x11000\" 124115\""
	dprintf("!dptrace_analyzer ");
	dprintf(COMMAND_POPEN);
	dprintf("\n\n");
	
	return S_OK;
}

/***********************************************************
 * !dptrace_help
 *
 * Purpose: Display usage help
 *          
 *
 *  Parameters:
 *     N/A
 *
 *  Return Values:
 *     N/A
 *
 ***********************************************************/
HRESULT
CALLBACK
dptrace_help(PDEBUG_CLIENT Client, PCSTR args)
{
    dprintf("Dual Purpose Tracer v1.0 Alpha - Copyright (C) 2008-2016\n" \
			"License: This software was created as companion to a Black Hat Presentation.\n" \
			"Developed by Rodrigo Rubira Branco (BSDaemon) <rodrigo@kernelhacking.com> and Rohit Mothe <rohitwas@gmail.com> (alphabetical order of names)\n" \
			"Heavily based on VDT-Tracer by Julio Auto and Rodrigo Branco\n\n");

	dprintf("!dptrace_trace <filename>	- trace the program until a breakpoint or exception and save the trace\n" \
		"	 in a file to be later consumed by the Visual Data Tracer GUI.\n");
	dprintf("!dptrace_forward <n(required) - s(required) - p(OPTIONAL)>		- forward analysis, either no arguments or all mandatory\n");
	dprintf("!dptrace_analyzer <analyzer_filepath> <trace_filepath> <close_gui> <controlled_ranges> <instr_index>\n");
	dprintf("!dptrace_analyzer_help	- help to the !dptrace_run_analyzer command\n");
	dprintf("!dptrace_forward_help	- help to the !dptrace_forward command\n");
	dprintf("!dptrace_help - this help screen											\n");

	return S_OK;
}

HRESULT
CALLBACK
dptrace_analyzer(PDEBUG_CLIENT Client, PSTR args)
{

	FILE *  pPipe;
	char   psBuffer[128];

	/* argument parsing is done in the analyzer !dptrace_analyzer <analyzer_filepath> <trace_filepath> <close_gui> <controlled_ranges> <instr_index> */
	dprintf("Args: %s\n", args);

	if (strlen(args) == 0) {
		dptrace_analyzer_help(NULL, NULL);
		return S_OK;
	}

	
	/* Debug-only DEFINES - to avoid argument parsing errors */
	
	/* dont keep GUI open*/
#define COMMAND_POPEN "\"\"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Debug\\DPTRACE-GUI.exe\" \"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Sample_output\\dptrace-test2.vdt\" 1 \"0x80000-0x81000,0x10000-0x11000\" 124115\""

	/* keep GUI open */
//#define COMMAND_POPEN "\"\"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Debug\\DPTRACE-GUI.exe\" \"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Sample_output\\dptrace-test2.vdt\" 0 \"0x80000-0x81000,0x10000-0x11000\" 124115\""
#define COMMAND_POPEN2 "dir *.c /on /p"
	//dprintf("Executing: ");
	//dprintf(COMMAND_POPEN);
	//dprintf("\n\n");

	/* end of Debug-only DEFINES */
	//if ((pPipe = _popen(COMMAND_POPEN, "rt")) == NULL) { //full path of the program u want to execute


	/* a good testing command line:
	!dptrace_analyzer "\"\"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Debug\\DPTRACE-GUI.exe\" \"C:\\Users\\rrbranco\\Desktop\\Black Hat 2016\\DPTrace-BlackHat 2016\\Sample_output\\dptrace-test2.dpt\" 0 \"0x80000-0x81000,0x10000-0x11000\" 124115\""
	*/
	//dprintf("Executing: %s", args);
	//dprintf("\n\n");

	if ((pPipe = _popen(args, "rt")) == NULL) { //full path of the program u want to execute
		dprintf("popen failed");
		return 0;
	}
	//dprintf("the output from the command...");
	while (fgets(psBuffer, 128, pPipe)) //read the stdout of called program into psBuffer
	{
		dprintf("%s", psBuffer);  //print the stdout of the called program in windbg console
	}

	/* Close pipe and print return value of pPipe. */
	/*if (feof(pPipe))
	{
		printf("\nProcess returned %d\n", _pclose(pPipe));
	}
	else
	{
		printf("Error: Failed to read the pipe to the end.\n");
	}*/

	return S_OK;
}


HRESULT
CALLBACK
dptrace_forward(PDEBUG_CLIENT Client, PSTR args)
{

	//Process Access Token:
#define PROCESS_ALL_ACCESS_REDEF      (0x000F0000 | 0x00100000 | 0xFFF)

	//Protection flags:
#define PAGE_EXECUTE  0x10
#define PAGE_EXECUTE_READ  0x20
#define PAGE_EXECUTE_READWRITE  0x40
#define PAGE_EXECUTE_WRITECOPY  0x80
#define PAGE_NOACCESS  0x01
#define PAGE_READONLY  0x02 // This is the defualt protection if run with no arguments as seen below.
#define PAGE_READWRITE  0x04
#define PAGE_WRITECOPY  0x08

	//Memory Protection Token:
#define VIRTUAL_MEM (0x1000 | 0x2000)  // (MEM_COMMIT | MEM_RESERVE)

	//Default Max Depth Setting
#define MAX_DEPTH 20 
#define MAX_SIZE 1024

	PDEBUG_SYSTEM_OBJECTS System;
	PDEBUG_CONTROL4 debugControl;
	DEBUG_VALUE    result;
	HRESULT      hres, Hr;
	ULONG        pid;

	//arguments and default values
	int n = 2; //default number of objects = 2
	int s = 40; //size of each object in bytes
	int p = 0x02; //default permissions of fake object are READ_ONLY

	//get PID of debuggee
	if ((Hr = Client->QueryInterface(__uuidof(IDebugSystemObjects), (void **)&System) == S_OK)){
		System->GetCurrentProcessSystemId(&pid);
	}
	else
	{
		dprintf("Error in obtaining Process ID of the debugee!");
		return 0;
	}
	//dprintf("\n********\n.. Process id of the debugee is %d\n",pid);
	HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS_REDEF, FALSE, pid);

	/*

	Arguments parsing+checking
	//Two options of running
	a) Simple Run with no arguments
	!dptrace_forward
	=> default number of objects n=2,size=40, permissions are RW for first object, READONLY for all other objects.

	b) If running with arguments to configure the run following rules apply-
	//!dptrace_forward -n(required) -s(required) -p(OPTIONAL)
	=>number of fake objects (required) , size of each object in bytes(required),  page permissions(OPTIONAL)(RWX/R/W/X/RW/RX/WX)

	1.if no args are provided then break out of arg parsing and continue to default case
	2. count number of arguments . If 2 then parse n,s. p remains default. If 3 then parse n,s,p. If args passed are only 1 check for "help" print help. else print "if passing arguments n and s are mandatory"
	2.n / number of objects < 1 print ("[*]The first argument n - (no. of fake objects) cannot be < 1 \n") exit(1); ; n > MAX_DEPTH print ("[*]The first argument n - (no. of fake objects) cannot be more than 20\n"); exit(1);
	3. if size > 1024 print ("[*]Exceeded max object size of 1024 bytes / 1KB!! quitting..") exit(1)
	4. in case argcount ==3 then switch cases to handle all different p / permission values and map it to appropriate int p. OR just take in P as a hexadecimal number and in the !dptrace_forward help print the commandline and the mem protect flags
	*/

	//START_LAME_ARGUMENT_PARSE 
	/* we could use an extension for that */
	size_t arg_length = strlen(args);
	if (!(arg_length == 0)){
		//argument list passed, now check if its valid
		//first trim extra spaces and count the number of spaces.
		PSTR first, back;
		first = back = args;

		if (first) do
		{
			while (*first == ' ' && *(first + 1) == ' ') first++;
		} while (*back++ = *first++);
		int whitespaces = 0;
		for (int i = 0; i < strlen(args); i++) {
			if ((args[i] == ' ') && (args[i + 1] != '\0') && (!(i == 0))) //Dont count any leftover trailing space after the last argument and NULl term of the string.Also disregard spaces before the first character begins
				whitespaces++;
		}
		//whitespaces+1 =number of arguments. if 2 then parse n and s. if one then check if its "help" if not print "if passing arguments n and s are mandatory"  and print commandline options again
		//if 3 parse n,s,p all as ints

		//dprintf("argument list is %s number of whitespaces= %d \n", args,whitespaces);
		int arg_count = whitespaces + 1;
		if ((arg_count == 1) && ((std::strcmp(args, "help")) == 0))
		{
			dptrace_forward_help(NULL, NULL);
			return 0;
		}
		else if ((arg_count == 2) || (arg_count == 3))
		{

			size_t arglist[2] = { 0, 0 };
			int j = 1;
			for (int i = 0; i < whitespaces; i++)
			{
				//list all whitespaces from first character to EOS. ignore first null terminator
				arglist[i] = std::string(args).find(' ', j); 
				j = arglist[i] + 1;
			}
			//dprintf("%d %d\n", arglist[0], arglist[1]);

			//[*] For now all parameters are expected to be specified in base 10/decimal number system. Hex and other base systems support in future versions. 
			n = atoi(((std::string(args)).substr(0, arglist[0])).c_str());
			if (arg_count == 3)
				s = atoi(((std::string(args)).substr(arglist[0] + 1, arglist[1] - 1)).c_str());


			else if (arg_count == 2)
				s = atoi(((std::string(args)).substr(arglist[0] + 1, strlen(args) - 1)).c_str());

			if (arglist[1] != 0) //if the third argument is present assume its p
			{
				//p = atoi(((std::string(args)).substr(arglist[1], strlen(args) - 1)).c_str());
				p = strtol(((std::string(args)).substr(arglist[1], strlen(args) - 1)).c_str(), NULL, 16);
			}

			//dprintf("passed value of n is %d \npassed value of s is %d \npassed value of p is %d\n\n", n, s, p);

		}
		else //argument count is either 1 and not "help" or more than 3 so print help and return
		{
			dprintf("Ouch, Invalid parameters!!! try !dptrace_help for help \n\n");
			return 0;
			//dprintf("[*] Two options of running\n\na) Simple Run with no arguments\n\t\t!dptrace_forward\n= > default number of objects n = 2, size = 40, permissions are RW for first object, READONLY for all other objects.\n\\nb) If running with arguments to configure the run following rules apply -\n\t\t!dptrace_forward -n(required) -s(required) -p(OPTIONAL) \n\t\t= >number of fake objects(required), size of each object in bytes(required), page permissions(OPTIONAL)(0x02,0x04,0x01)(R / RW / W / NO_ACCESS,... )\n\n For passing 'p' use the following map-\n#define PAGE_EXECUTE  0x10\nPAGE_EXECUTE_READ  0x20\n\nPAGE_EXECUTE_READWRITE  0x40\n\nPAGE_EXECUTE_WRITECOPY  0x80\n\nPAGE_NOACCESS  0x01\n\nPAGE_READONLY  0x02 // This is the defualt protection if run with no arguments. \n\nPAGE_READWRITE  0x04\n\nPAGE_WRITECOPY  0x08\n");
		}
	}
	else
	{
		dprintf("[*] No Arguments passed, using default n=2, s=40 (bytes) and p=0x02 <(read only)>\n[*] For help with arguments type !dptrace_help for help\n\n");
	}
	//check basic sanity of the parameters n.s and p.
	if (s > MAX_SIZE)
	{
		dprintf("[*] Exceeded max object size of 1024 bytes !! quitting..\n\n");
		return 0;
	}
	if (n > MAX_DEPTH){
		dprintf("[*] Exceeded max number of objects (20)!! quitting..\n\n");
		return 0;
	}
	if ((n < 1) || (s <4)){
		dprintf("[*]The first argument n - (no. of fake objects) cannot be < 1 and the second argument s(size of object) cannot be less than 4\n");
		return 0;
	}

	if (!(p == 0x10) && !(p == 0x20) && !(p == 0x40) && !(p == 0x80) && !(p == 0x01) && !(p == 0x02) && !(p == 0x04) && !(p == 0x08))
	{
		dprintf("[*] Unkown/Unsupported memory protection  constant!! try `!dptrace_help` for a list of valid  constants\n quitting..\n\n");
		return 0;
	}
	//END_LAME_ARGUMENT_PARSE
	

	//Get IDebugControl Interface for executing commands via the debugger engine.
	Hr = Client->QueryInterface(__uuidof(IDebugControl), (void **)&debugControl);
	if (Hr != S_OK) {
		DWORD Err_code = GetLastError();
		dprintf("[*]Error in getting DebugControl interface %d\n", Err_code);
		return 0;
	}

	//SPECIAL CASE(arguments provided) & n=1 =>only one object filled with CC CCC CC... and allocated with permissions p 
	LPVOID single_base_address;
	if (n == 1){
		LPVOID single_base_address = VirtualAllocEx(h_process, 0, s, VIRTUAL_MEM, PAGE_READWRITE);
		//dprintf("[*] Base address of Object-1 is %x\n", single_base_address);
		char s1[] = "f ";
		char s2[100];
		std::sprintf(s2, "%x%c", single_base_address, '\0');
		char s3[] = " L1000 CC CC CC CC";
		std::strcat(s1, s2);
		std::strcat(s1, s3);
		//dprintf(".. Executing Command %s\n", s1);
		hres = debugControl->Execute(DEBUG_OUTCTL_IGNORE, s1, 0);
		DWORD oldprotect = NULL;
		BOOL status = VirtualProtectEx(h_process, single_base_address, 1024, p, &oldprotect);
		if (status == 0){
			DWORD Err_code = GetLastError();
			dprintf("!! Error in VirtualProtectEx Error Code- %d%n", Err_code);
			return 0;
		}
		//dprintf("[*] Root of the linked memory object chain allocated at %x\n\n********\n\n ", single_base_address);
		//Print the range of the allocated memory object chain to the console in the format that the tracer expects --> "range1_low-range1_high, range2_low-range2_high, ..."
		dprintf("%s%x%c%x%s", "\n\n Allocated range is\n" , single_base_address, '-', (size_t(single_base_address) + 4096), '\n\n');
		return S_OK;
	}
	//SPECIAL CASE ENDS

	//ALL OTHER CASES i.e n>=2 and s and p are valid.
	else{
		LPVOID base_address[MAX_DEPTH] = { 0 };
		for (int i = 0; i<n; i++){
			base_address[i] = VirtualAllocEx(h_process, 0, s, VIRTUAL_MEM, PAGE_READWRITE); //Initially allocate everything with RW as we will make some changes below. 
			//dprintf("[*] Base address  of Object-%d is %x\n", i, base_address[i]);
		}																				//This will later be vprotect'd according to the 'p' parameter.
		char s1[100];
		strcpy(s1, "ed ");
		char s2[100];
		char s3[100];
		char s4[100];
		char s5[100];
		strcpy(s5, "f ");
		char s6[100];
		int OBJ_MAX = (s + 4);
		for (int i = 0; i<n - 1; i++){
			for (int each_dword = 0; each_dword < OBJ_MAX; (each_dword += 4)){ //We fill every alloc block to the nearest DWORD multiple of size 's' bytes.
				strcpy(s1, "ed ");
				std::sprintf(s2, "%x%c%c%x%c%x%c%c%x", base_address[i], '+', ' ', each_dword, ' ', base_address[i + 1], '+', ' ', each_dword);
				std::strcat(s1, s2);
				//dprintf(".. Executing Command1-> %s\n", s1);
				hres = debugControl->Execute(DEBUG_OUTCTL_THIS_CLIENT, s1, 0); //ed address_obj1 + i address_obj2 + i => *object[i] = &object2[i] 	
			}
			strcpy(s3, "f ");
			//virtualallocex allocs a 4096 bytes(small page size 4KB) per object. fill the memory area after the object of s(size) bytes with 0x41414141
			std::sprintf(s4, "%x%c%c%x%s%x%s", base_address[i], '+', ' ', s, " L1000-", s, " 41 41 41 41");//assumption is object size requested is not more than 1024 bytes.
			std::strcat(s3, s4);
			//dprintf(".. Executing Command2-> %s\n", s3);
			hres = debugControl->Execute(DEBUG_OUTCTL_IGNORE, s3, 0);
		}
		strcpy(s5, "f ");
		//Last object gets filled with junk values 0xCCCCCC...
		std::sprintf(s6, "%x%s", base_address[n - 1], " L1000 CC CC CC CC");
		std::strcat(s5, s6);
		//dprintf(".. Executing Command3 %s\n", s5);
		hres = debugControl->Execute(DEBUG_OUTCTL_IGNORE, s5, 0);


		//Finally VirtualProtectEx all objects(except the first one/Master object to permissions p specififed by user
		for (int i = 1; i<n; i++){
			DWORD oldprotect = NULL;
			BOOL status = VirtualProtectEx(h_process, base_address[i], 1024, p, &oldprotect);//again assuming user specified object size is not more than 1024 bytes
			if (status == 0){
				DWORD Err_code = GetLastError();
				dprintf("!! Error in VirtualProtectEx Error Code- %d%n", Err_code);
				return(0);
			}
		}
		//dprintf("[*] Root of the linked memory object chain allocated at %x\n\n********\n\n", base_address[0]);
		//dprintf("The range of free fake memory blocks is ->\n%s");
		//Print the range of the allocated memory object chain to the console in the format that the tracer expects --> "range1_low-range1_high, range2_low-range2_high, ..."
		char final_string[200];
		char temp_string[200];
		char comma[200];
		strcpy(final_string,"");
		//strcpy(temp_string, " ");
		//strcpy(final_string, " ");
		for (int i = 0; i < n; i++){
			std::sprintf(temp_string, "%x%c%x", base_address[i], '-', (size_t(base_address[i])+4096));
			if (!((i == 0)) && (!(i == n))) {
				strcpy(comma, ",");
				std::strcat(comma, temp_string);
				std::strcat(final_string, comma);
			}
			else
				std::strcat(final_string, temp_string);
		}
		dprintf("\n\n Allocated range is\n%s\n\n",final_string);

	}
	//ALL OTHER CASES END


	return S_OK;
}







typedef union
{
	CHAR Str[256];
	struct
	{
		CHAR Mnem[8];
		CHAR Dst[16];
		CHAR Src[16];
		CHAR SrcDep1[4];
		CHAR SrcDep2[4];
		CHAR SrcDep3[4];
		CHAR Disas[204];
	} Members;

} VdtEntry;

enum VDT_OPERANDS
{
	VDT_SRC,
	VDT_DST
};

inline HRESULT VdtParseOperands(VdtEntry *Entry, CHAR *RawOps, PDEBUG_REGISTERS2 Registers2, VDT_OPERANDS Type)
{	
	size_t CharsCopied = 0;

	if (Type == VDT_SRC)
	{
		Entry->Members.SrcDep1[0] = '\0';
		Entry->Members.SrcDep2[0] = '\0';
		Entry->Members.SrcDep3[0] = '\0';

		// Offset (resolved constant)
		if (RawOps[0] == 'o')
		{
			CHAR *TempStr = strchr(RawOps, '(');
			assert(TempStr != 0);

			// We always have 8 digits here
			strncpy(Entry->Members.Src, TempStr+1, 8);
			CharsCopied = 8;
		}
		// Constant number
		else if (RawOps[0] >= 0x30 && RawOps[0] <= 0x39)
		{
			CharsCopied = strspn(RawOps, "1234567890ABCDEF");
			strncpy(Entry->Members.Src, RawOps, CharsCopied);
		}
		// Pointer
		else if (strstr(RawOps, "ptr"))
		{			
			// Get from context: $ea (and $ea2 for rightmost param, if applicable)
			ULONG RegIndex;
			DEBUG_VALUE RegValue;
			if (Registers2->GetPseudoIndexByName("$ea", &RegIndex) != S_OK)
			{
				dprintf("Error: Could not get $ea index\n");
				return S_FALSE;
			}
			if (Registers2->GetPseudoValues(DEBUG_REGSRC_DEBUGGEE, 1, NULL, RegIndex, &RegValue) != S_OK)
			{
				dprintf("Error: Could not get $ea value\n");
				return S_FALSE;
			}

			sprintf(Entry->Members.Src, "*%08x", RegValue.I32);
			CharsCopied = 9;

			// If it's not a symbol, parse for register dependence - only for SRC operands
			CHAR *PtrBegin = strchr(RawOps, '[') + 1;
			CHAR *PtrEnd = strchr(RawOps, ']');
			assert(PtrEnd != 0);
			size_t PtrLen = PtrEnd - PtrBegin;

			CHAR TempStr[256];
			memcpy(TempStr, PtrBegin, PtrLen);
			TempStr[PtrLen] = '\0';

			if (!strchr(TempStr, '('))
			{
				int i = 0;
				PCHAR YetAnotherTempPtr = strtok(TempStr, "+-*/");
				while (YetAnotherTempPtr)
				{
					// Constants are not dependences
					if (YetAnotherTempPtr[0] >= 0x30 && YetAnotherTempPtr[0] <= 0x39)
						break;

					if (!i)
						strcpy(Entry->Members.SrcDep1, YetAnotherTempPtr);
					else
					{
						strcpy(Entry->Members.SrcDep2, YetAnotherTempPtr);
						i++; break;
					}

					i++;
					YetAnotherTempPtr = strtok(NULL, "+-*/");
				}				
			}
			
		}
		// Register
		else
		{
			CharsCopied = strspn(RawOps, "abcdefghijklmnopqrstuvwxyz");
			strncpy(Entry->Members.Src, RawOps, CharsCopied);
		}

		Entry->Members.Src[CharsCopied] = '\0';
	}
	// Seriously: fix this! This duplication of code is ridiculous!
	// Type == VDT_DST
	else
	{
		// Offset (resolved constant)
		if (RawOps[0] == 'o')
		{
			CHAR *TempStr = strchr(RawOps, '(');
			assert(TempStr != 0);

			// We always have 8 digits here
			strncpy(Entry->Members.Dst, TempStr+1, 8);
			CharsCopied = 8;
		}
		// Constant number
		else if (RawOps[0] >= 0x30 && RawOps[0] <= 0x39)
		{
			CharsCopied = strspn(RawOps, "1234567890ABCDEF");
			strncpy(Entry->Members.Dst, RawOps, CharsCopied);
		}
		// Pointer
		else if (strstr(RawOps, "ptr"))
		{			
			// Get from context: $ea (and $ea2 for rightmost param, if applicable)
			ULONG RegIndex;
			DEBUG_VALUE RegValue;
			if (Registers2->GetPseudoIndexByName("$ea", &RegIndex) != S_OK)
			{
				dprintf("Error: Could not get $ea index\n");
				return S_FALSE;
			}
			if (Registers2->GetPseudoValues(DEBUG_REGSRC_DEBUGGEE, 1, NULL, RegIndex, &RegValue) != S_OK)
			{
				dprintf("Error: Could not get $ea value\n");
				return S_FALSE;
			}

			sprintf(Entry->Members.Dst, "*%08x", RegValue.I32);
			CharsCopied = 9;
			
		}
		// Register
		else
		{
			CharsCopied = strspn(RawOps, "abcdefghijklmnopqrstuvwxyz");
			strncpy(Entry->Members.Dst, RawOps, CharsCopied);
		}

		Entry->Members.Dst[CharsCopied] = '\0';
	}
	return S_OK;
}

/***********************************************************
 * !dptrace_trace
 *
 * Purpose: Trace and dump to a file
 *          
 *
 *  Parameters:
 *    !dptrace_trace <out-filename>
 *
 *  Return Values:
 *     N/A
 *
 ***********************************************************/
HRESULT
CALLBACK
dptrace_trace(PDEBUG_CLIENT Client, PSTR args)
{
// Helping macro for this function only
// It crashes when I pass NULL in the 4th param?!?!? o.O
#define WriteEntryToFile(f,e) \
			if(FALSE == WriteFile(f, e, 256, (ULONG*) &Dummy, NULL)) \
			{ \
				dprintf("Could not write to file (error %d)\n", GetLastError()); \
				Instrs--; Success = FALSE; \
				break; \
			} \
			DumpedInstrs++;




	ULONG MaxDisassembleLength = 1000; // Should be enough

	HANDLE File = NULL;
	PSTR InFilename = NULL;
	PSTR Buffer, TmpToken, Opcodes;
	CHAR FullMnem[32];
	VdtEntry Entry;
	ULONG CurIndex = -1;
	BOOL Success = FALSE;

	CONTEXT Context;
	ULONG Pid, Tid, EventType, Instrs, DumpedInstrs;
	ULONG64 Dummy;

	PDEBUG_CONTROL Control;
	PDEBUG_ADVANCED Advanced;
	PDEBUG_REGISTERS Registers;
	PDEBUG_REGISTERS2 Registers2;
	PDEBUG_SYMBOLS Symbols;
	Client->QueryInterface(__uuidof(IDebugControl), (void **) &Control);
	Client->QueryInterface(__uuidof(IDebugAdvanced), (void **) &Advanced);
	Client->QueryInterface(__uuidof(IDebugRegisters), (void **) &Registers);
	Client->QueryInterface(__uuidof(IDebugRegisters2), (void **) &Registers2);
	Client->QueryInterface(__uuidof(IDebugSymbols), (void **) &Symbols);

	if (!Advanced || !Control) {
		dprintf("Error!\n");
		goto e_release;
	}

	size_t StrBoundary = strcspn(args, " \t\n\0");
	char BkupChar = args[StrBoundary];
	args[StrBoundary] = '\0';

	if ((File = CreateFile(args, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
		== INVALID_HANDLE_VALUE) {
		dprintf("Invalid parameter!\n Type !dptrace_help for more information.\n");
		goto e_release;
	}

	args[StrBoundary] = BkupChar;

	/* The following is not yet implemented. It refers to accepting the input filename
	   as a parameter so we can automatically find the input memory range (where the file
	   is mapped in the address space)
	// If we have more than just the first argument (i.e. - we are passed the input filename)
	if (strlen(args) > StrBoundary)
	{
		StrBoundary += strspn(args+StrBoundary, " \t\n\0");
		InFilename = (PSTR) calloc(strlen(args+StrBoundary)+1, sizeof(CHAR));
		strcpy(InFilename, args+StrBoundary);

		IDebugBreakpoint *bptPtr = NULL;
		Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID, &bptPtr);
		ULONG64 FncOffset;
		if (Symbols->GetOffsetByName("kernel32!MapViewOfFile", &FncOffset) != E_FAIL)
		{
			bptPtr->SetOffset(FncOffset);
			bptPtr->AddFlags(DEBUG_BREAKPOINT_ENABLED);
		}
		dprintf("%d\n",FncOffset);
	}
	*/

	if (!(Buffer = (PSTR) calloc(MaxDisassembleLength, sizeof(CHAR)))) {
		dprintf("Error while allocating memory\n");
		goto e_release;
	}

	// Write the magic of the file header
	if(FALSE == WriteFile(File, VDT_FILE_MAGIC, sizeof(VDT_FILE_MAGIC), (ULONG*) &Dummy, NULL)) \
	{
		dprintf("Could not write to file (error %d)\n", GetLastError());
		goto e_release;
	}

	Success = TRUE;

	Instrs = DumpedInstrs = 0;
	time_t then = time(NULL);

	do {
		Instrs++;
		
		if (Advanced->GetThreadContext(&Context, sizeof(Context)) != S_OK) {
			Instrs--; Success = FALSE;
			dprintf("Error while getting the current thread context\n");
			break;
		}

		if (Control->Disassemble(Context.Eip, DEBUG_DISASM_EFFECTIVE_ADDRESS, Buffer, 
									MaxDisassembleLength, NULL, &Dummy) != S_OK) {
			Instrs--; Success = FALSE;
			dprintf("Error while disassembling\n");
			break;
		};


		memcpy(Entry.Members.Disas, Buffer, sizeof(Entry.Members.Disas)-1);

		// Skip the first part (instruction address)
		strtok(Buffer, " \t\n");

		// Instruction bytes
		Opcodes = strtok(NULL, " \t\n");

		// Instruction mnemonic
		TmpToken = strtok(NULL, " \t\n");

		// Discard prefixes
		while (Opcodes[0])
		{
			// Prefixes not shown in the disassembly (operand size, address size, segment override, etc)
			if (*((USHORT*)Opcodes) == 0x3632 || *((USHORT*)Opcodes) == 0x6532 || *((USHORT*)Opcodes) == 0x3633
					|| *((USHORT*)Opcodes) == 0x6533 || *((USHORT*)Opcodes) == 0x3436 || *((USHORT*)Opcodes) == 0x3536
					|| *((USHORT*)Opcodes) == 0x3636 || *((USHORT*)Opcodes) == 0x3736 
					/* || *((USHORT*)Opcodes) == 0x6239 --> Not treating 'WAIT' as prefix right now */)
				Opcodes += 2;
		
			// 'rep' prefix
			else if (*((USHORT*)TmpToken) == 0x6572 && TmpToken[2] == 'p')
			{
				TmpToken = strtok(NULL, " \t\n");
				Opcodes += 2;
			}
			// 'lock' prefix
			else if (*((ULONG*)TmpToken) == 0x6b636f6c)
			{
				TmpToken = strtok(NULL, " \t\n");
				Opcodes += 2;
			}
			else
				break;
		}
					

		memcpy(Entry.Members.Mnem, TmpToken, sizeof(Entry.Members.Mnem));
		Entry.Members.Mnem[sizeof(Entry.Members.Mnem)-1] = '\0';


		// If it's a push (no pusha or pushf), write it in the file
		if (*((ULONG*)TmpToken) == 0x68737570 && !TmpToken[4])
		{
			// Manually restoring a tokenized string - bad idea
			TmpToken += strspn(TmpToken+strlen(TmpToken)+1, " \t\n") + strlen(TmpToken) + 1;

			sprintf(Entry.Members.Dst, "*%08x", Context.Esp - 4);
			if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_SRC) != S_OK)
				break;
			WriteEntryToFile(File, Entry.Str);
		}
		// Or if it's a pop
		else if (*((USHORT*)TmpToken) == 0x6F70 && TmpToken[2] == 'p')
		{
			// No popa, popf, etc
			if (!TmpToken[3])
			{
				// Manually restoring a tokenized string - bad idea
				TmpToken += strspn(TmpToken+strlen(TmpToken)+1, " \t\n") + strlen(TmpToken) + 1;

				sprintf(Entry.Members.Src, "*%08x", Context.Esp);
				Entry.Members.SrcDep1[0] = '\0';
				Entry.Members.SrcDep2[0] = '\0';
				if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_DST) != S_OK)
					break;
				WriteEntryToFile(File, Entry.Str);
			}
		}
		// IN and INS (can be used as stop conditions)
		else if (*((USHORT*)TmpToken) == 0x6E69 && 
				((TmpToken[2] != 't') && (TmpToken[2] != 'v') && (TmpToken[2] != 'c')))
		{
			Entry.Members.Src[0] = '\0';
			Entry.Members.SrcDep1[0] = '\0';
			Entry.Members.SrcDep2[0] = '\0';
			Entry.Members.SrcDep3[0] = '\0';

			// Manually restoring a tokenized string - bad idea
			TmpToken += strspn(TmpToken+strlen(TmpToken)+1, " \t\n") + strlen(TmpToken) + 1;

			if (Entry.Members.Mnem[2] == 's')
				sprintf(Entry.Members.Dst, "*%08x", Context.Edi);
			else
			{
				TmpToken = strtok(TmpToken, ",");
				if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_DST) != S_OK)
					break;
			}

			WriteEntryToFile(File, Entry.Str);
		}
		// SETcc (has to be logged with incomplete info)
		else if (*((USHORT*)TmpToken) == 0x6573)
		{
			Entry.Members.Src[0] = '\0';
			Entry.Members.SrcDep1[0] = '\0';
			Entry.Members.SrcDep2[0] = '\0';
			Entry.Members.SrcDep3[0] = '\0';

			// Manually restoring a tokenized string - bad idea
			TmpToken += strspn(TmpToken+strlen(TmpToken)+1, " \t\n") + strlen(TmpToken) + 1;

			TmpToken = strtok(TmpToken, ",");
			if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_DST) != S_OK)
				break;

			WriteEntryToFile(File, Entry.Str);
		}
		// RDTSC and RDPMC (stop condition for EDX and EAX)
		else if (*((USHORT*)TmpToken) == 0x6472)
		{
			Entry.Members.Src[0] = '\0';
			Entry.Members.SrcDep1[0] = '\0';
			Entry.Members.SrcDep2[0] = '\0';
			Entry.Members.SrcDep3[0] = '\0';

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'a'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'd'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);
		}
		// CPUID (stop condition for EAX, EBX, ECX, and EDX)
		else if (*((USHORT*)TmpToken) == 0x7063)
		{
			Entry.Members.Src[0] = '\0';
			Entry.Members.SrcDep1[0] = '\0';
			Entry.Members.SrcDep2[0] = '\0';
			Entry.Members.SrcDep3[0] = '\0';

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'a'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'b'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'c'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);

			Entry.Members.Dst[0] = 'e'; Entry.Members.Dst[1] = 'd'; Entry.Members.Dst[2] = 'x'; Entry.Members.Dst[3] = '\0'; 
			WriteEntryToFile(File, Entry.Str);
		}
		// CALL, RET, SYSCALL, SYSENTER, etc... (we log it just so that the output trace doesn't look so weird)
		else if ((*((USHORT*)TmpToken) == 0x7973) || // SY*
					(*((USHORT*)TmpToken) == 0x6163) || // CA*
					(*((USHORT*)TmpToken) == 0x6E69 && TmpToken[2] == 't') || // INT*
					(*((USHORT*)TmpToken) == 0x6572)) // RE*
		{
			Entry.Members.Dst[0] = '\0';
			Entry.Members.Src[0] = '\0';
			Entry.Members.SrcDep1[0] = '\0';
			Entry.Members.SrcDep2[0] = '\0';
			Entry.Members.SrcDep3[0] = '\0';

			WriteEntryToFile(File, Entry.Str);
		}
		else
		{
			// We need some info from the opcodes to get the right reference entry
			if (*((USHORT*)Opcodes) == 0x6630)
				sprintf(FullMnem, "%c%c%c%c-%s", Opcodes[0], Opcodes[1], Opcodes[2], Opcodes[3], TmpToken);
			else
				sprintf(FullMnem, "%c%c-%s", Opcodes[0], Opcodes[1], TmpToken);

			// Manually restoring a tokenized string - bad idea
			TmpToken += strspn(TmpToken+strlen(TmpToken)+1, " \t\n") + strlen(TmpToken) + 1;
			
			VdtInstr Instr = InstructionDefs[FullMnem];

			//dprintf("%s %p %p\n", FullMnem, Instr.Dst, Instr.Src);
		
			// We are mostly interested in instructions that have a source and a destination operand
			if (Instr.Dst && Instr.Src)
			{
				// String instructions
				if (strlen(Entry.Members.Mnem) == 4 && Entry.Members.Mnem[3] == 's')
				{
					// Trouble coming ahead - if the isntruction is rep'ed, we have no effective address 
					// information available in the disassembly text outpput.
					// We need to parse differently, with the help of the x86ref and the context
					// Use the context to get register (and, therefore, EA) info

					if (IsCharAlphaA(Instr.Dst[0]))
					{							
						strcpy(Entry.Members.Dst, Instr.Dst);
					}
					else
					{
						sprintf(Entry.Members.Dst, "*%08x", Context.Edi);
					}

					if (Instr.Src[0] == '-')
					{
						sprintf(Entry.Members.Src, "*%08x", Context.Esi);
						Entry.Members.SrcDep1[0] = 'e'; Entry.Members.SrcDep1[1] = 's'; Entry.Members.SrcDep1[2] = 'i'; Entry.Members.SrcDep1[3] = '\0';
					}
					else
					{
						strcpy(Entry.Members.Src, Instr.Src);
						Entry.Members.SrcDep1[0] = '\0';
					}
					
					Entry.Members.SrcDep2[0] = '\0';
					Entry.Members.SrcDep3[0] = '\0';
				}

				// Else if it's LEA
				else if (*((USHORT *)Entry.Members.Mnem) == 0x656c && Entry.Members.Mnem[2] == 'a')
				{
					// LEA requires a slightly special way of parsing
					// Its source operand looks like a 'ptr' operand but, in reality, it's not.
					// Nevertheless, we'll borrow some code from the 'ptr' operand parsing.

					TmpToken = strtok(TmpToken, ",");
					if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_DST) != S_OK)
						break;

					TmpToken = strtok(NULL, ",");
					TmpToken = strchr(TmpToken, '[') + 1;
					PCHAR PtrEnd = strchr(TmpToken, ']');
					assert(PtrEnd != 0);
					*PtrEnd = '\0';

					PCHAR AnotherTempPtr;
					PCHAR YetAnotherTempPtr;

					// If it's just a constant - why the hell don't they just a use a MOV, then?
					if ((AnotherTempPtr = strchr(TmpToken, '(')))
					{
						strncpy(Entry.Members.Src, AnotherTempPtr+1, 8);
						Entry.Members.Src[8] = '\0';
						Entry.Members.SrcDep1[0] = '\0';
					}
					else
					{
						int i = 0;
						YetAnotherTempPtr = strtok(TmpToken, "+-*/");
						while (YetAnotherTempPtr)
						{
							if (YetAnotherTempPtr[0] >= 0x30 && YetAnotherTempPtr[0] <= 0x39)
								break;
							if (!i)
								strcpy(Entry.Members.Src, YetAnotherTempPtr);
							else
							{
								strcpy(Entry.Members.SrcDep1, YetAnotherTempPtr);
								i++; break;
							}

							i++;
							YetAnotherTempPtr = strtok(NULL, "+-*/");
						}

						if (!i)
							Entry.Members.Src[0] = '\0';
						else if (i == 1)
							Entry.Members.SrcDep1[0] = '\0';
					}

					Entry.Members.SrcDep2[0] = '\0';
					Entry.Members.SrcDep3[0] = '\0';
				}

				// End of 'special cases' - parse as usual
				else
				{
					if (IsCharAlphaA(Instr.Dst[0]))
					{
						strcpy(Entry.Members.Dst, Instr.Dst);
					}
					else
					{
						TmpToken = strtok(TmpToken, ",");
						if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_DST) != S_OK)
							break;
					}

					if (Instr.Src[0] == '-')
					{
						TmpToken = strtok(NULL, ",");
						if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_SRC) != S_OK)
							break;
					}
					else if (Instr.Src[0] == 'x')
					{
						strcpy(Entry.Members.Src, Instr.Dst);
						
						Entry.Members.SrcDep1[0] = '\0';
						Entry.Members.SrcDep2[0] = '\0';
						Entry.Members.SrcDep3[0] = '\0';
					}
					else if (Instr.Src[0] == '*')
					{
						TmpToken = strtok(NULL, ",");
						if (VdtParseOperands(&Entry, TmpToken, Registers2, VDT_SRC) != S_OK)
							break;

						if (Entry.Members.SrcDep1[0] == '\0')
							strcpy(Entry.Members.SrcDep1, Instr.Dst);
						else if (Entry.Members.SrcDep2[0] == '\0')
							strcpy(Entry.Members.SrcDep2, Instr.Dst);
						else if (Entry.Members.SrcDep3[0] == '\0')
							strcpy(Entry.Members.SrcDep3, Instr.Dst);
					}
					else
					{
						strcpy(Entry.Members.Src, Instr.Src);

						Entry.Members.SrcDep1[0] = '\0';
						Entry.Members.SrcDep2[0] = '\0';
						Entry.Members.SrcDep3[0] = '\0';
					}
				}

				int DstLen = strlen(Entry.Members.Dst);
				if (DstLen >= 2 &&
					Entry.Members.Dst[DstLen-2] == 'd' &&
					Entry.Members.Dst[DstLen-1] == 'a')
				{
					Entry.Members.Dst[DstLen-1] = 'x';
					WriteEntryToFile(File, Entry.Str);

					Entry.Members.Dst[DstLen-2] = 'a';
				}

				//dprintf("Here!\n");
				WriteEntryToFile(File, Entry.Str);
			}
		}


		if (Control->SetExecutionStatus(DEBUG_STATUS_STEP_INTO) != S_OK) {
			Instrs--; Success = FALSE;
			dprintf("Error while setting the execution status to stepping mode\n");
			break;
		}

		if (Control->WaitForEvent(0, 1000) != S_OK) {
			Instrs--; Success = FALSE;
			dprintf("Error while waiting for event\n");
			break;
		}

		char extrainf[256];
		unsigned long extraused;
		if (Control->GetLastEventInformation(&EventType, &Pid, &Tid, extrainf, 256, &extraused, NULL, 0, NULL) != S_OK) {
			Instrs--; Success = FALSE;
			dprintf("Error while trying to get information on the last event\n");
			break;
		}

		if (EventType == DEBUG_EVENT_BREAKPOINT)
			dptrace_help(NULL, NULL);

	} while (!EventType); // EventType == 0 for the tracing steps (undocumented)

	dprintf("\nA total of %u instructions were traced and %u were dumped to %s\n", 
			Instrs, DumpedInstrs, args);

	if (!EventType)
		dprintf("This command ended abruptly. The output file is not suited for analysis\n");

	time_t now = time(NULL);

	dprintf("Duration of this command in seconds: %f\n\n", difftime(now, then));

	free(Buffer);

	CloseHandle(File);

e_release:
	if (Advanced) Advanced->Release();
	if (Control) Control->Release();

	return (Success ? S_OK : E_FAIL);

#undef WriteEntryToFile
}

